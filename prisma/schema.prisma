// Struxient Prisma Schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Minimal model to verify migration pipeline
model HealthCheck {
  id        String   @id @default(cuid())
  status    String   @default("ok")
  checkedAt DateTime @default(now())
}

// =============================================================================
// TENANT & MEMBERSHIP
// =============================================================================

model Company {
  id        String   @id @default(cuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members         CompanyMember[]
  workflows       Workflow[]
  flowGroups      FlowGroup[]
  customers       Customer[]
  jobs            Job[]
  externalParties ExternalParty[]
  draftBuffers    WorkflowDraftBuffer[]
  draftEvents     WorkflowDraftEvent[]
  scheduleRequests ScheduleChangeRequest[]
  scheduleBlocks   ScheduleBlock[]
}

/// Membership role within a company
enum MemberRole {
  OWNER
  ADMIN
  MANAGER
  WORKER
}

/// Links a user (Clerk ID) to a company with a role and capability overrides
model CompanyMember {
  id        String     @id @default(cuid())
  companyId String
  userId    String     // Clerk user ID
  role      MemberRole @default(WORKER)

  /// Capability overrides: { allow: string[], deny: string[] }
  /// Member-level allow/deny override role defaults.
  /// Deny always wins over allow.
  capabilities Json @default("{\"allow\":[],\"deny\":[]}")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // Responsibility Back-relations
  assignments          JobAssignment[] @relation("MemberAssignments")
  performedAssignments JobAssignment[] @relation("AssignedBy")

  @@unique([companyId, userId])
  @@index([userId])
  @@index([companyId])
}

// =============================================================================
// DOMAIN: JOBS & CUSTOMERS (PHASE 3 / M1)
// =============================================================================

model Customer {
  id        String   @id @default(cuid())
  companyId String
  name      String

  jobs      Job[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
}

model Job {
  id          String   @id @default(cuid())
  companyId   String
  customerId  String
  flowGroupId String   @unique

  flowGroup   FlowGroup @relation(fields: [flowGroupId], references: [id], onDelete: Restrict)

  address     String?

  customer    Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // Responsibility Back-relation
  assignments JobAssignment[]
  scheduleBlocks ScheduleBlock[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([companyId])
}

// =============================================================================
// DOMAIN: RESPONSIBILITY / ASSIGNMENTS (PHASE 1)
// =============================================================================

enum AssigneeType {
  PERSON
  EXTERNAL
}

/// External Party metadata-only model (no userId, no auth)
model ExternalParty {
  id        String   @id @default(cuid())
  companyId String
  name      String
  email     String?
  phone     String?
  metadata  Json?    // Optional arbitrary metadata

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  company     Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  assignments JobAssignment[]

  @@index([companyId])
}

/// Append-only Job Assignment record
model JobAssignment {
  id             String       @id @default(cuid())
  jobId          String
  slotKey        String       // e.g. "PM", "SALES_LEAD"
  assigneeType   AssigneeType
  
  // Assignee: PERSON (CompanyMember) or EXTERNAL (ExternalParty)
  memberId        String?
  externalPartyId String?

  // Attribution
  assignedByMemberId String   // CompanyMember who performed the assignment
  
  // Append-only Supersession
  supersededAt   DateTime?    // Null means current active assignment for this slot
  
  createdAt      DateTime     @default(now())

  job           Job            @relation(fields: [jobId], references: [id], onDelete: Cascade)
  member        CompanyMember? @relation("MemberAssignments", fields: [memberId], references: [id], onDelete: SetNull)
  externalParty ExternalParty? @relation(fields: [externalPartyId], references: [id], onDelete: SetNull)
  assignedBy    CompanyMember  @relation("AssignedBy", fields: [assignedByMemberId], references: [id], onDelete: Restrict)

  @@index([jobId, slotKey, supersededAt])
  @@index([memberId, supersededAt])
  @@index([externalPartyId, supersededAt])
}

// =============================================================================
// FLOWSPEC: WORKFLOW SPECIFICATION (DESIGN-TIME)
// Canon: 10_flowspec_engine_contract.md, 00_flowspec_glossary.md
// =============================================================================

/// Workflow specification (design-time blueprint)
/// A Workflow is a versioned, immutable graph specification that describes
/// the structure, tasks, outcomes, and routing rules for a type of work.
model Workflow {
  id               String         @id @default(cuid())
  name             String
  description      String?
  status           WorkflowStatus @default(DRAFT)
  version          Int            @default(1)
  isNonTerminating Boolean        @default(false)
  companyId        String
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  publishedAt      DateTime?

  // Template provenance (immutable after import)
  // Set only by createWorkflowFromTemplate; excluded from update path
  templateId      String?   // Source template ID
  templateVersion Int?      // Source template version at import time
  importedAt      DateTime? // When template was imported (no @default)
  importedBy      String?   // User ID who imported

  nodes       Node[]
  gates       Gate[]
  versions    WorkflowVersion[]
  flows       Flow[]
  fanOutRules FanOutRule[]
  draftBuffer WorkflowDraftBuffer?
  draftEvents WorkflowDraftEvent[]

  company Company @relation(fields: [companyId], references: [id])

  @@unique([companyId, name, version])
  @@index([companyId])
}

/// Workflow lifecycle states
/// Draft: Editable, not executable
/// Validated: Passed validation, ready to publish
/// Published: Immutable, executable
enum WorkflowStatus {
  DRAFT
  VALIDATED
  PUBLISHED
}

/// Immutable published version snapshot
/// Created when a Workflow is published. Contains complete workflow structure
/// at publish time. Flows are bound to a specific version at creation.
/// INV-010: Flow bound to version, INV-011: Published workflows are immutable
model WorkflowVersion {
  id          String   @id @default(cuid())
  workflowId  String
  version     Int
  snapshot    Json     // Complete workflow structure at publish time
  publishedAt DateTime @default(now())
  publishedBy String   // User ID who published

  workflow Workflow @relation(fields: [workflowId], references: [id])
  flows    Flow[]

  @@unique([workflowId, version])
}

// =============================================================================
// FLOWSPEC: BUILDER DRAFT SAFETY (PHASE 1)
// Canon: Builder Save Safety v1
// =============================================================================

/// Draft change event type
enum DraftEventType {
  INITIAL
  COMMIT
  RESTORE
}

/// Work-in-progress buffer for semantic workflow changes.
/// Tenant-scoped, exactly one buffer per workflow.
model WorkflowDraftBuffer {
  id          String   @id @default(cuid())
  companyId   String
  workflowId  String   @unique
  content     Json     // WIP semantic structure (WorkflowSnapshot shape)
  updatedAt   DateTime @updatedAt
  updatedBy   String   // User ID who last edited
  baseEventId String?  // Anchor event ID for diffing against relational Truth

  company   Company             @relation(fields: [companyId], references: [id], onDelete: Cascade)
  workflow  Workflow            @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  baseEvent WorkflowDraftEvent? @relation(fields: [baseEventId], references: [id], onDelete: SetNull)

  @@unique([companyId, workflowId])
  @@index([companyId, workflowId])
}

/// Append-only history of saved/committed draft events.
/// Provides the "Time Machine" for restoring previous versions.
model WorkflowDraftEvent {
  id              String         @id @default(cuid())
  companyId       String
  workflowId      String
  seq             Int            // Sequential order within workflow (managed by app)
  type            DraftEventType
  label           String?        // User-provided milestone name
  snapshot        Json           // Full composite snapshot (semantic + layout)
  createdAt       DateTime       @default(now())
  createdBy       String         // User ID who created the event
  restoresEventId String?        // FK for RESTORE type events

  company      Company             @relation(fields: [companyId], references: [id], onDelete: Cascade)
  workflow     Workflow            @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  restoredFrom WorkflowDraftEvent? @relation("RestoreReference", fields: [restoresEventId], references: [id], onDelete: SetNull)
  restoredBy   WorkflowDraftEvent[] @relation("RestoreReference")
  baseForBuffers WorkflowDraftBuffer[]

  @@unique([workflowId, seq])
  @@index([companyId, workflowId])
  @@index([workflowId, createdAt])
}

/// Node container within a Workflow
/// A Node is a named container that groups one or more Tasks.
/// Nodes define started/done semantics for the grouped Tasks.
model Node {
  id             String         @id @default(cuid())
  workflowId     String
  name           String
  isEntry        Boolean        @default(false)
  nodeKind       NodeKind       @default(MAINLINE)
  completionRule CompletionRule @default(ALL_TASKS_DONE)
  specificTasks  String[]       // For SPECIFIC_TASKS_DONE rule - list of Task IDs
  position       Json?          // { x: number, y: number } for Builder UI

  workflow      Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  tasks         Task[]
  outboundGates Gate[]   @relation("SourceNode")
  inboundGates  Gate[]   @relation("TargetNode")

  @@unique([workflowId, name])
}

/// Node completion rules
/// ALL_TASKS_DONE: Node is done when ALL Tasks have recorded Outcomes
/// ANY_TASK_DONE: Node is done when ANY Task has recorded an Outcome
/// SPECIFIC_TASKS_DONE: Node is done when specified subset of Tasks have recorded Outcomes
enum CompletionRule {
  ALL_TASKS_DONE
  ANY_TASK_DONE
  SPECIFIC_TASKS_DONE
}

/// Node kind (Mainline vs Detour)
enum NodeKind {
  MAINLINE
  DETOUR
}

/// Task definition within a Node
/// A Task is the atomic unit of work. All execution happens at the Task level.
/// Tasks have explicit, enumerated Outcomes.
/// INV-001: No work outside Tasks
model Task {
  id               String  @id @default(cuid())
  nodeId           String
  name             String
  instructions     String?
  evidenceRequired Boolean @default(false)
  evidenceSchema   Json?   // Schema for required evidence validation
  displayOrder     Int     @default(0)
  defaultSlaHours  Int?    // Template-level default SLA (hours). Policy can override (B > A > null)

  node                  Node                  @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  outcomes              Outcome[]
  crossFlowDependencies CrossFlowDependency[]

  @@unique([nodeId, name])
}

/// Outcome definition for a Task
/// Outcomes are explicit, enumerated results of completing a Task.
/// INV-002: Explicit outcomes only - no inferred or freeform outcomes
model Outcome {
  id     String @id @default(cuid())
  taskId String
  name   String // e.g., "APPROVED", "REJECTED", "NEEDS_REVISION"

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@unique([taskId, name])
}

/// Gate routing rule
/// Gates route execution to the next Node(s) based on Outcomes.
/// Gates are keyed by (nodeId, outcomeName) - routing operates at Node level.
/// INV-003: Gates route only, INV-024: Gate key is Node-level
model Gate {
  id           String  @id @default(cuid())
  workflowId   String
  sourceNodeId String
  outcomeName  String  // Routes by outcome name at Node level
  targetNodeId String? // null = terminal path (no further routing)

  workflow   Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  sourceNode Node     @relation("SourceNode", fields: [sourceNodeId], references: [id], onDelete: Cascade)
  targetNode Node?    @relation("TargetNode", fields: [targetNodeId], references: [id], onDelete: SetNull)

  @@unique([workflowId, sourceNodeId, outcomeName])
}

/// Cross-flow dependency definition
/// Allows Tasks in one Flow to wait for Outcomes in another Flow
/// before becoming Actionable.
/// INV-017: Cross-flow dependencies are user-authored
/// INV-021: Scoped to Flow Group only
model CrossFlowDependency {
  id               String @id @default(cuid())
  taskId           String
  sourceWorkflowId String
  sourceTaskPath   String // "nodeId.taskId" or similar identifier
  requiredOutcome  String

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@index([taskId])
}

/// Fan-out rule stored in Workflow specification
/// Defines when completing a Node with a specific outcome should
/// trigger instantiation of other workflows.
/// NOTE: No targetVersion field - v2 always resolves to Latest Published (§10.3.1)
model FanOutRule {
  id               String @id @default(cuid())
  workflowId       String
  sourceNodeId     String
  triggerOutcome   String
  targetWorkflowId String

  workflow Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  @@index([workflowId])
}

// =============================================================================
// FLOWSPEC: FLOW EXECUTION (RUNTIME)
// Canon: 10_flowspec_engine_contract.md §10, 00_flowspec_glossary.md §2.3
// =============================================================================

/// Flow Group - groups related flows executing for the same unit of work
/// Flow Groups are bound by Scope (1:1 relationship).
/// INV-021: Cross-flow dependencies scoped to Flow Group
model FlowGroup {
  id        String   @id @default(cuid())
  scopeType String   // "job", "project", etc.
  scopeId   String   // Unique ID within scope type
  companyId String
  createdAt DateTime @default(now())

  job     Job?
  flows   Flow[]
  policy  FlowGroupPolicy?
  company Company @relation(fields: [companyId], references: [id])

  @@unique([companyId, scopeType, scopeId])
}

// =============================================================================
// FLOWSPEC: FLOW GROUP POLICY (OPERATIONAL CONFIG)
// Policy affects timing/signals ONLY, never workflow structure.
// Policy tables may have @updatedAt since they are mutable config, NOT Truth.
// =============================================================================

/// Priority levels for job urgency signaling
/// Used for UI signals only; does NOT affect canonical actionable ordering.
enum JobPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

/// FlowGroup-level policy for operational overrides (1:1 with FlowGroup)
/// Policy can override timing/signals but NEVER workflow structure.
/// This is mutable config, not Truth - has @updatedAt.
model FlowGroupPolicy {
  id           String       @id @default(cuid())
  flowGroupId  String       @unique
  jobPriority  JobPriority  @default(NORMAL)
  groupDueAt   DateTime?    // Optional hard deadline for entire group
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  flowGroup     FlowGroup            @relation(fields: [flowGroupId], references: [id], onDelete: Cascade)
  taskOverrides TaskPolicyOverride[]

  @@index([flowGroupId])
}

/// Task-level SLA overrides within a FlowGroup
/// Keyed by [policyId, taskId]. taskId references Task.id in the bound workflow snapshot.
/// Validation: taskId MUST exist in the FlowGroup's bound workflow version snapshot.
model TaskPolicyOverride {
  id                 String @id @default(cuid())
  flowGroupPolicyId  String
  taskId             String // References Task.id in workflow snapshot (not FK - snapshot is JSON)
  slaHours           Int?   // Override SLA in hours. Merge: override > default > null

  policy FlowGroupPolicy @relation(fields: [flowGroupPolicyId], references: [id], onDelete: Cascade)

  @@unique([flowGroupPolicyId, taskId])
  @@index([flowGroupPolicyId])
}

/// Flow instance (runtime execution)
/// A Flow is a live execution instance of a Workflow.
/// INV-010: Flow bound to Workflow version at creation time
model Flow {
  id                String     @id @default(cuid())
  workflowId        String
  workflowVersionId String
  flowGroupId       String
  status            FlowStatus @default(ACTIVE)
  createdAt         DateTime   @default(now())
  completedAt       DateTime?

  workflow        Workflow        @relation(fields: [workflowId], references: [id])
  workflowVersion WorkflowVersion @relation(fields: [workflowVersionId], references: [id])
  flowGroup       FlowGroup       @relation(fields: [flowGroupId], references: [id])

  // Truth tables - using Restrict to preserve audit trail (no Cascade)
  nodeActivations     NodeActivation[]
  taskExecutions      TaskExecution[]
  evidenceAttachments EvidenceAttachment[]
  detours             DetourRecord[]
  scheduleRequests    ScheduleChangeRequest[]
  scheduleBlocks      ScheduleBlock[]

  @@index([flowGroupId])
  @@index([workflowId])
}

/// Flow execution status
/// ACTIVE: Flow is executing
/// COMPLETED: Flow reached terminal condition
/// SUSPENDED: Flow paused (e.g., step limit exceeded)
/// BLOCKED: Fan-out failure; visible, terminal for v2 (INV-023)
enum FlowStatus {
  ACTIVE
  COMPLETED
  SUSPENDED
  BLOCKED
}

// =============================================================================
// FLOWSPEC: TRUTH TABLES (IMMUTABLE EXECUTION RECORDS)
// Canon: 00_flowspec_glossary.md §3.1, 20_flowspec_invariants.md
// 
// CRITICAL: These tables are Truth - append-only, immutable.
// - NO @updatedAt (INV-007: Outcome Immutability)
// - NO onDelete: Cascade (audit trail preservation)
// - NO actionable column (INV-006: Derived state not stored)
// =============================================================================

/// Node activation event (Truth)
/// Recorded when a Node becomes active via Entry designation or Gate routing.
/// This is Truth - immutable once recorded.
/// INV-007: No @updatedAt, INV-009: Only FlowSpec mutates Truth
model NodeActivation {
  id          String   @id @default(cuid())
  flowId      String
  nodeId      String
  activatedAt DateTime @default(now())
  iteration   Int      @default(1) // For cycle tracking - new activation = new iteration

  // Using Restrict instead of Cascade to preserve audit trail
  flow Flow @relation(fields: [flowId], references: [id], onDelete: Restrict)

  @@index([flowId, nodeId])
}

/// Task execution state (Truth)
/// Records Task start and Outcome. Outcomes are immutable once recorded.
/// INV-007: Outcome immutability - no @updatedAt
/// INV-009: Only FlowSpec mutates Truth
model TaskExecution {
  id               String    @id @default(cuid())
  flowId           String
  taskId           String
  nodeActivationId String?   // Links to which node activation triggered this
  startedAt        DateTime? // When work began on the Task
  startedBy        String?   // User ID who started the Task
  outcome          String?   // Recorded outcome (immutable once set)
  outcomeAt        DateTime? // When outcome was recorded
  outcomeBy        String?   // User ID who recorded the outcome
  iteration        Int       @default(1) // For cycle tracking

  resolvedDetourId String?   // FK to DetourRecord that this outcome resolved

  // Using Restrict instead of Cascade to preserve audit trail
  flow                 Flow            @relation(fields: [flowId], references: [id], onDelete: Restrict)
  validityEvents       ValidityEvent[]
  checkpointForDetours DetourRecord[]  @relation("CheckpointDetours")

  @@index([flowId, taskId])
}

/// Detour record for corrections and failure handling
model DetourRecord {
  id                        String       @id @default(cuid())
  flowId                    String
  checkpointNodeId          String
  checkpointTaskExecutionId String?      // Anchored to an existing TaskExecution
  resumeTargetNodeId        String
  type                      DetourType   @default(NON_BLOCKING)
  status                    DetourStatus @default(ACTIVE)
  category                  String?      // e.g., "COMPLIANCE", "DATA_FIX"
  repeatIndex               Int          @default(0) // flow+node scoped count
  openedAt                  DateTime     @default(now())
  openedBy                  String
  escalatedAt               DateTime?
  escalatedBy               String?
  resolvedAt                DateTime?
  resolvedBy                String?
  convertedAt               DateTime?
  convertedBy               String?

  flow                    Flow           @relation(fields: [flowId], references: [id], onDelete: Restrict)
  checkpointTaskExecution TaskExecution? @relation("CheckpointDetours", fields: [checkpointTaskExecutionId], references: [id])
  scheduleRequests        ScheduleChangeRequest[]

  @@index([flowId, status])
  @@index([flowId, checkpointNodeId])
}

enum DetourStatus {
  ACTIVE
  RESOLVED
  CONVERTED
}

enum DetourType {
  NON_BLOCKING
  BLOCKING
}

/// Validity event for task outcomes (append-only)
model ValidityEvent {
  id              String        @id @default(cuid())
  taskExecutionId String
  state           ValidityState
  reason          String?
  createdAt       DateTime      @default(now())
  createdBy       String

  taskExecution TaskExecution @relation(fields: [taskExecutionId], references: [id], onDelete: Restrict)

  @@index([taskExecutionId, createdAt])
}

enum ValidityState {
  VALID
  PROVISIONAL
  INVALID
}

/// Evidence attachment (Truth)
/// Evidence attached to a Task. Evidence is append-only, cannot be deleted.
/// INV-005: No floating evidence - always attached to a Task
/// INV-007: No @updatedAt (immutable)
model EvidenceAttachment {
  id              String       @id @default(cuid())
  flowId          String
  taskId          String
  taskExecutionId String?
  type            EvidenceType
  data            Json         // File reference or structured content
  attachedAt      DateTime     @default(now())
  attachedBy      String       // User ID who attached
  idempotencyKey  String?      // For preventing duplicate attachments

  // Using Restrict instead of Cascade to preserve audit trail
  flow Flow @relation(fields: [flowId], references: [id], onDelete: Restrict)

  @@unique([idempotencyKey])
  @@index([flowId, taskId])
}

/// Evidence types
enum EvidenceType {
  FILE
  TEXT
  STRUCTURED
}

// =============================================================================
// FLOWSPEC: FAN-OUT FAILURE TRACKING
// Canon: 10_flowspec_engine_contract.md §10.3.2
// 
// NOTE: No retriedAt or retryCount fields - retry is explicitly deferred from v2
// =============================================================================

/// Fan-out failure log
/// Records when fan-out instantiation fails. Flow enters BLOCKED state.
/// INV-023: Outcome preserved, Flow blocked on failure
/// NOTE: No retry mechanism in v2 (§10.3.2 explicit deferral)
model FanOutFailure {
  id                String   @id @default(cuid())
  triggeringFlowId  String
  triggeringTaskId  String
  triggeringOutcome String
  targetWorkflowId  String
  errorReason       String
  createdAt         DateTime @default(now())
  resolved          Boolean  @default(false) // Manual resolution flag

  @@index([triggeringFlowId])
  @@index([resolved])
}

// =============================================================================
// FLOWSPEC: WORKFLOW TEMPLATES (SYSTEM-DEFINED)
// Pre-built workflow blueprints for import into tenant workspaces.
// Templates are non-executing; importing creates a tenant-owned DRAFT.
// =============================================================================

/// Workflow template (system-defined, non-executing)
/// Templates store a WorkflowSnapshot JSON structure for cloning into tenant workflows.
/// Templates have no companyId - they are system-global and read-only.
/// Updates require inserting a new version row (no in-place edits).
model WorkflowTemplate {
  id          String   @id @default(cuid())
  tradeKey    String   // e.g., "HVAC", "ROOFING", "PLUMBING"
  category    String   // e.g., "SALES", "INSTALL", "FINANCE"
  name        String
  description String?
  version     Int      @default(1)
  definition  Json     // WorkflowSnapshot structure
  tags        String[] // e.g., ["Residential", "Commercial"]
  isFixture   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([tradeKey, name, version])
  @@index([tradeKey, category])
}

// =============================================================================
// DOMAIN: SCHEDULING (PHASE C)
// Canon: 00_scheduling_foundation.md, 01_scheduling_invariants_and_guards.canon.md
// =============================================================================

/// Canonical schedule time classes
enum ScheduleTimeClass {
  COMMITTED
  PLANNED
  REQUESTED
  SUGGESTED
}

/// Request for a schedule change (e.g. from Calendar UI)
/// Does not mutate truth directly; must be resolved via task outcome.
model ScheduleChangeRequest {
  id             String            @id @default(cuid())
  companyId      String
  flowId         String?
  taskId         String?
  detourRecordId String?
  timeClass      ScheduleTimeClass @default(PLANNED)
  status         String            @default("PENDING") // PENDING, APPROVED, REJECTED, CANCELLED
  reason         String?           // User-provided reason for change
  metadata       Json?             // Requested window, resource changes, etc.

  // Audit
  requestedAt DateTime @default(now())
  requestedBy String   // ActorId
  reviewedAt  DateTime?
  reviewedBy  String?

  company      Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  flow         Flow?          @relation(fields: [flowId], references: [id], onDelete: SetNull)
  detourRecord DetourRecord?  @relation(fields: [detourRecordId], references: [id], onDelete: SetNull)
  blocks       ScheduleBlock[]

  @@index([companyId, status])
  @@index([flowId])
}

/// Append-only record of schedule truth
/// Linked to tasks/flows/detours.
model ScheduleBlock {
  id           String            @id @default(cuid())
  companyId    String
  jobId        String?
  flowId       String?
  taskId       String?           // Canonical link to truth source
  resourceId   String?           // Crew/Member/Equipment ID
  resourceType String?           // "CREW", "MEMBER", "EQUIPMENT"
  timeClass    ScheduleTimeClass
  startAt      DateTime
  endAt        DateTime
  metadata     Json?             // Flexible storage for secondary attributes

  // Audit & History
  createdAt    DateTime  @default(now())
  createdBy    String    // ActorId
  supersededAt DateTime? // If set, this block is historical
  supersededBy String?   // Pointer to new block ID (not FK for append-only simplicity)

  changeRequestId String?   // Link to request that created this

  company       Company                @relation(fields: [companyId], references: [id], onDelete: Cascade)
  job           Job?                   @relation(fields: [jobId], references: [id], onDelete: SetNull)
  flow          Flow?                  @relation(fields: [flowId], references: [id], onDelete: SetNull)
  changeRequest ScheduleChangeRequest? @relation(fields: [changeRequestId], references: [id], onDelete: SetNull)

  @@index([companyId, timeClass, supersededAt])
  @@index([startAt, endAt])
  @@index([resourceId, supersededAt])
  @@index([jobId])
  @@index([flowId, taskId])
}
